//src/database/databaseAggregateFunctions.ts
import sqlite3 from "sqlite3";
import path from 'path';

export class DatabaseAggregateFunctions {

  db: sqlite3.Database;

  constructor(name: string) {
    const dbPath = path.resolve(process.cwd(), `${name}.db`);
    this.db = new sqlite3.Database(dbPath, (err: Error | null) => {
      if (err)
        console.error(err.message);
      else
        console.log(`Connected to the SQLite database: ./${name}.db.`);
    });
  }

  //gets all rows in database from sql statement
  getAllQuery(sql: string, params: any[] = []): Promise<any> {
    return new Promise((resolve, reject) => {
      this.db.all(sql, params, function (this: sqlite3.RunResult, err: Error | null, rows: any) {
        if (err) {
          console.error("Error running sql: " + sql);
          console.error(err.message);
          reject(err);
        }
        else
          resolve(rows || []);
      });
    });
  }

  //runs provided sql query with parameters
  runQuery(sql: string, params: any[] = []): Promise<any> {
    return new Promise((resolve, reject) => {
      this.db.run(sql, params, function (this: sqlite3.RunResult, err: Error | null) {
        if (err) {
          console.error(err.message);
          console.log("Error running sql: " + sql);
          console.log(err);
          reject(err);
        }
        else
          resolve({ id: (this && (this as any).lastID) });
      });
    });
  }

  //gets a single row from the database
  getQuery(sql: string, params: any[] = []): Promise<any> {
    return new Promise((resolve, reject) => {
      this.db.get(sql, params, (err: Error | null, row: any) => {
        if (err) return reject(err);
        console.log("Row found!:", row);
        resolve(row);
      });
    });
  }

  async addOutbox(type: string, aggregateId: number, payload: any, createdAt: string): Promise<void> {
    const sql = "INSERT INTO Outbox (outboxType, AggregateId, Payload, CreatedAt, Processed) VALUES (?, ?, ?, ?, ?)";
    await this.runQuery(sql, [type, aggregateId, JSON.stringify(payload), createdAt, 0]);
  }
  //creates an event with outbox pattern implemented
  async createUserWithOutbox(username: string, password: string, Email: string, commandID: string): Promise<any> {

    //Start Transaction
    await this.runQuery("BEGIN TRANSACTION");

    try {
      //save Command ID in database
      const sqlCommand = "INSERT INTO Commands (CommandID) VALUES (?)";
      await this.runQuery(sqlCommand, [commandID]);

      //Insert into users
      const sqlUser = "INSERT INTO users (email, username, pass) VALUES (?, ?, ?)"
      const newUserID = await this.runQuery(sqlUser, [Email, username, password]);

      //Insert into Outbox (Using the new user ID)
      const outboxPayload = {
        userId: newUserID,
        password: password,
        email: Email,
        status: 'Created'
      };

      const sqlOutbox = "INSERT INTO Outbox (outboxType, AggregateId, Payload, CreatedAt, Processed) VALUES (?, ?, ?, ?, ?)";
      await this.runQuery(sqlOutbox, ['UserCreated', (newUserID && (newUserID as any).id) || newUserID, JSON.stringify(outboxPayload), new Date().toISOString(), 0]);

      // Commit Transaction
      await this.runQuery("COMMIT");

      return newUserID;

    } catch (err) {
      console.error("Transaction failed, rolling back", err);
      await this.runQuery("ROLLBACK");
      throw err;
    }
  }

  //creates an event with outbox pattern implemented
  async createEventWithOutbox(userId: number, groupId: number, eventTitle: string, description: string, dateTime: string | Date, type: string): Promise<any> {

    const dateObj = new Date(dateTime);
    const day = dateObj.getDate();
    const month = dateObj.getMonth() + 1;
    const year = dateObj.getFullYear();
    const startTime = dateObj.toLocaleTimeString();
    //default event duration is 1 hour - can be modified later
    const endDateObj = new Date(dateObj.getTime() + (60 * 60 * 1000));
    const endTime = endDateObj.toLocaleTimeString();

    //Start Transaction
    await this.runQuery("BEGIN TRANSACTION");

    try {
      //Insert into EventCore
      const sqlECore = "INSERT INTO EventCore (Title, Description) VALUES (?, ?)";
      const coreResult = await this.runQuery(sqlECore, [eventTitle, description]);
      const newEventID = (coreResult && (coreResult as any).id) || coreResult; // Capture the ID generated by SQLite

      //Insert into EventTime
      const sqlETime = "INSERT INTO EventTime (EventID, StartTime, EndTime, Day, Month, EYear) VALUES (?, ?, ?, ?, ?, ?)";
      await this.runQuery(sqlETime, [newEventID, startTime, endTime, day, month, year]);

      //find if type exists, if not insert it
      const sqlFindType = "SELECT Tid FROM Type WHERE Tname = ?";
      const existingType = await this.getQuery(sqlFindType, [type]);
      let typeID;

      if (existingType) {
        typeID = existingType.Tid;
      } else {
        const sqlInsertType = "INSERT INTO Type (Tname) VALUES (?)";
        const typeResult = await this.runQuery(sqlInsertType, [type]);
        typeID = (typeResult && (typeResult as any).id) || typeResult;
      }

      const sqlEventType = "INSERT INTO EventType (TypeID, EventID) VALUES (?, ?)";
      await this.runQuery(sqlEventType, [typeID, newEventID]);

      //find calendar ID from GCal for that group
      const calIds = await this.findCidsFromGCal(groupId);
      //if calendar does not exist for group, abort
      if (calIds.length === 0) {
        throw new Error(`No calendar found for Group ID: ${groupId}. Event creation aborted.`);
      }

      // Proceed if calendar exists
      const sqlEventAdd = "INSERT INTO EventAdd (CalendarID, EventID) VALUES (?, ?)";
      await this.runQuery(sqlEventAdd, [calIds[0], newEventID]);

      //Insert into Outbox (Using the new Event ID)
      const outboxPayload = {
        eventId: newEventID,
        userId: userId,
        groupId: groupId,
        title: eventTitle,
        status: 'Created'
      };

      const sqlOutbox = "INSERT INTO Outbox (outboxType, AggregateId, Payload, CreatedAt, Processed) VALUES (?, ?, ?, ?, ?)";
      await this.runQuery(sqlOutbox, ['EventCreated', newEventID, JSON.stringify(outboxPayload), new Date().toISOString(), 0]);

      // Commit Transaction
      await this.runQuery("COMMIT");

      return newEventID;

    } catch (err) {
      console.error("Transaction failed, rolling back", err);
      await this.runQuery("ROLLBACK");
      throw err;
    }
  }

  //Adds a new user to the database
  async addUser(name: string, pass: string): Promise<number | undefined> {
    // Insert a new user into the Users table
    const sql = "INSERT INTO Users (username, pass) VALUES (?, ?)";
    try{
      const result = await this.runQuery(sql, [name, pass]);
    
      //console.log(`User ${name} added.`);
      //console.log(`The User ID is ${result.id}`);
    
      return (result && (result as any).id) || undefined;
    }
    catch (err){
      console.error("Error adding User:", err);
    }
  }

  //adds a new group with that user as a member - complete
  async addGroup(name: string, userID: number): Promise<void> {
    const sqlGroup = "INSERT INTO Groups (Gname) VALUES (?)";
    const sqlIncludes = "INSERT INTO Included (Userid, Groupid) VALUES (?, ?)";

    try{
      //Insert the new group into Groups table
      const result = await this.runQuery(sqlGroup, [name]);
      //console.log(`Group ${name} added to the database.`);

      // Get the ID of the newly created group
      const GroupID = result.id;
      //console.log(`The Group ID is ${GroupID}`);

      //Insert the mapping of group and user into Included table
      await this.runQuery(sqlIncludes, [userID, GroupID]);
      //console.log(`User ${userID} added to Group ${GroupID}.`);
    } catch (err){
      console.error("Error adding group:", err);
    }
  }

  //Adds a user to an existing group - complete
  async addUserToGroup(UserID: number, GroupID: number): Promise<void> {
    const sqlIncludes = "INSERT INTO Included (Userid, Groupid) VALUES (?, ?)";

    try{
      //map a new user to a group via included table
      await this.runQuery(sqlIncludes, [UserID, GroupID]);
      //console.log(`User ${userID} added to Group ${GroupID}.`);
    } catch (err){
      console.error("Error adding group:", err);
    }
  }

  //Adds a new availability to the user - complete
  async addAvailability(userID: number, startTime: string, endTime: string, Day: number, Month: number, Year: number): Promise<void> {
    const sqlAvail = "INSERT INTO Availability (Day, Month, AYear, StartTime, EndTime) VALUES (?, ?, ?, ?, ?)";
    const sqlHas = "INSERT INTO Has (UserID, AvailID) VALUES (?, ?)";
    try{
      //Insert the new availability into Availability table
      const result = await this.runQuery(sqlAvail, [Day, Month, Year, startTime, endTime]);
      //console.log(`Availability ${result.id} added to the Avail table.`);

      //Insert the mapping of availability and user into Has table
      await this.runQuery(sqlHas, [userID, result.id]);
      //console.log(`Availability ${result.id} added to the Has table.`);
    }
    catch (err){
      console.error("Error Adding Availability:", err);
    }
  }

  //Adds a new event to a calendar - complete
  async addEvent(ETitle: string, Description: string, Type: string, StartTime: string, EndTime: string, Day: number, Month: number, Year: number, CalID: number): Promise<void> {
    const sqlECore = "INSERT INTO EventCore (Title, Description) VALUES (?, ?)";
    const sqlETime = "INSERT INTO EventTime (EventID, StartTime, EndTime, Day, Month, EYear) VALUES (?, ?, ?, ?, ?, ?)";
    const sqlEventAdd = "INSERT INTO EventAdd (CalendarID, EventID) VALUES (?, ?)";
    const sqlEType = "INSERT INTO Type (Tname) VALUES (?)";
    const sqlEventType = "INSERT INTO EventType (TypeID, EventID) VALUES (?, ?)";
    try {
      const result = await this.runQuery(sqlECore, [ETitle, Description]);
      //console.log(`Event ${ETitle} added to EventCore.`);

      await this.runQuery(sqlETime, [result.id, StartTime, EndTime, Day, Month, Year]);
      //console.log(`Event ${result.id} added to EventTime.`);

      await this.runQuery(sqlEventAdd, [CalID, result.id]);
      //console.log(`Event ${result.id} added to EventAdd.`);

      const typeObject = await this.runQuery(sqlEType, [Type]);

      await this.runQuery(sqlEventType, [typeObject.id, result.id]);

    } catch (err){
      console.error("Error adding Event:", err);
    }
  }

  //Adds a blank calendar to a group - complete
  async addBlankCalendar(Gid: number, calName: string): Promise<void> {

    const sql = "INSERT INTO Calendar (Cname) VALUES (?)";
    const sqlGCal = "INSERT INTO GCal (GroupID, CalendarID) VALUES (?, ?)";
    try{
      const result = await this.runQuery(sql, [calName]);
    
      //console.log(`Calender ${calName} added.`);
      //console.log(`The Calendar ID is ${result.id}`);
      
      await this.runQuery(sqlGCal, [Gid, result.id]);

      //console.log(`mapping of Group and Calendar`);
    }
    catch (err){
      console.error("Error adding Calendar:", err);
    }
  }

  //Adds a new type of Event to the database - complete
  async addEventType(typeName: string, Eid: number): Promise<void> {

    const sqlType = "INSERT INTO Type (Tname) VALUES (?)";
    const sqlEventType = "INSERT INTO EventType (TypeID, EventID) VALUES (?, ?)";
    try{
      const result = await this.runQuery(sqlType, [typeName]);
      //console.log(`Type ${typeName} added.`);
      
      await this.runQuery(sqlEventType, [result.id, Eid]);
      //console.log(`mapping of Type and Event added`);
    }
    catch (err){
      console.error("Error adding Type:", err);
    }
  }

  //deletes an availability from the database - complete
  async deleteAvailability(Aid: number): Promise<void> {
    const sqlDeleteAvail = "DELETE FROM Availability WHERE Aid = ?";
    const sqlDeleteHas = "DELETE FROM Has WHERE AvailID = ?";

    //wrap all sql commands in a "Packet" so that in the instance of a server crash,
    //it can rollback to the previous stable state
    await this.runQuery("BEGIN TRANSACTION");
    try{
      //Delete all mappings of this Avail to User from Has table
      await this.runQuery(sqlDeleteHas, [Aid]);
      console.log(`Avail ${Aid} Deleted from Has.`);

      //Delete the Avail from Availability table
      await this.runQuery(sqlDeleteAvail, [Aid]);
      console.log(`Avail ${Aid} Deleted from Avail.`);

      //end the transaction
      await this.runQuery("COMMIT");
    }
    catch (err){
      //roll back the delete if error occured
      await this.runQuery("ROLLBACK");
      console.error("Error deleting Type:", err);
    }
  }

  //deletes a Type from the database - complete
  async deleteType(Tid: number): Promise<void> {
    const sqlDeleteType = "DELETE FROM Type WHERE Tid = ?";
    const sqlDeleteEType = "DELETE FROM EventType WHERE TypeID = ?";

    //wrap all sql commands in a "Packet" so that in the instance of a server crash,
    //it can rollback to the previous stable state
    await this.runQuery("BEGIN TRANSACTION");
    try{
      //Delete all mappings of this Type to Events from EventType table
      await this.runQuery(sqlDeleteEType, [Tid]);
      console.log(`Type ${Tid} Deleted from EventType.`);

      //Delete the Type from Type table
      await this.runQuery(sqlDeleteType, [Tid]);
      console.log(`Type ${Tid} Deleted from Type.`);

      //end the transaction
      await this.runQuery("COMMIT");
    }
    catch (err){
      //roll back the delete if error occured
      await this.runQuery("ROLLBACK");
      console.error("Error deleting Type:", err);
    }
  }

  //Deletes a Group from the database - complete
  //Also needs to delete all child nodes including, Calandars, Events,
  //EventCore, EventTime, EventType and their mapping tables in buisiness logic
  async deleteGroup(GroupID: number): Promise<void> {
    const sqlDeleteGCal = "DELETE FROM GCal WHERE GroupID = ?";
    const sqlDeleteGroup = "DELETE FROM Groups WHERE Gid = ?";
    const sqlDeleteIncluded = "DELETE FROM Included WHERE GroupID = ?";

    await this.runQuery("BEGIN TRANSACTION");
    try {
      //Delete all mappings of this group to calendars from GCal table
      await this.runQuery(sqlDeleteGCal, [GroupID]);
      console.log(`Group ${GroupID} Deleted from GCal.`);

      //delete all mappings of this group to users from Included table
      await this.runQuery(sqlDeleteIncluded, [GroupID]);
      console.log(`Group ${GroupID} Deleted from Included.`);

      //Delete the group from Groups table
      await this.runQuery(sqlDeleteGroup, [GroupID]);
      console.log(`Group ${GroupID} Deleted from Groups.`);

      await this.runQuery("COMMIT");
    }
    catch (err) {
      //roll back the delete if error occured
      await this.runQuery("ROLLBACK");
      console.error("Error deleting User:", err);
    }
    
  }

  //Deletes a user from the database - complete
  //Also needs to delete all child nodes including Availability during its call stack, 
  //and possibly groups if they are the only one that is in that group
  async deleteUser(UserID: number): Promise<void> {
    const sqlDeleteIncluded = "DELETE FROM Included WHERE UserID = ?";
    const sqlDeleteUser = "DELETE FROM Users WHERE Uid = ?";
    const sqlDeleteUHas = "DELETE FROM Has WHERE UserID = ?";

    //wrap all sql commands in a "Packet" so that in the instance of a server crash,
    //it can rollback to the previous stable state
    await this.runQuery("BEGIN TRANSACTION");
    try{
      //Delete all mappings of this user to groups from Included table
      await this.runQuery(sqlDeleteIncluded, [UserID]);
      console.log(`User ${UserID} Deleted from Included.`);

      //Delete the user from Users table
      await this.runQuery(sqlDeleteUser, [UserID]);
      console.log(`User ${UserID} Deleted from Users.`);

      //Delete the user mapping from has table
      await this.runQuery(sqlDeleteUHas, [UserID]);
      console.log(`User ${UserID} Deleted from Has.`);
  
      //end the transaction
      await this.runQuery("COMMIT");
    }
    catch (err){
      //roll back the delete if error occured
      await this.runQuery("ROLLBACK");
      console.error("Error deleting User:", err);
    }
  }

  //removes a user's access to a group - Complete
  async removeUserFromGroup(UserID: number, GroupID: number): Promise<void> {
    const sqlDeleteIncluded = "DELETE FROM Included WHERE UserID = ? AND GroupID = ?";

    //wrap all sql commands in a "Packet" so that in the instance of a server crash,
    //it can rollback to the previous stable state
    await this.runQuery("BEGIN TRANSACTION");

    try{
      await this.runQuery(sqlDeleteIncluded, [UserID, GroupID]);
      console.log(`User ${UserID} Deleted from Included.`);
      //end the transaction
      await this.runQuery("COMMIT");
    }
    catch (err){
      //roll back the delete if error occured
      await this.runQuery("ROLLBACK");
      console.error("Error deleting include:", err);
    }
  }

  //Deletes a calendar from a group - complete
  async deleteCalendar(groupID: number, calID: number): Promise<void> {
    const sqlDeleteGCal = "DELETE FROM GCal WHERE (GroupID, CalendarID) = (?, ?)";
    const sqlDeleteCal = "DELETE FROM Calendar WHERE Cid = ?";
    const sqlDeleteEventAdded = "DELETE FROM EventAdd WHERE CalendarID = ?";

    //wrap all sql commands in a "Packet" so that in the instance of a server crash,
    //it can rollback to the previous stable state
    await this.runQuery("BEGIN TRANSACTION");
    try{
      //Delete all mappings of this user to groups from Included table
      await this.runQuery(sqlDeleteGCal, [groupID, calID]);
      console.log(`Calendar mapping ${calID} Deleted from GCal.`);

      //Delete the user from Users table
      await this.runQuery(sqlDeleteCal, [calID]);
      console.log(`Calendar ${calID} Deleted from Calendar.`);

      //Delete the user from Users table
      await this.runQuery(sqlDeleteEventAdded, [calID]);
      console.log(`Calendar mapping ${calID} Deleted from EventAdded.`);

      //end the transaction
      await this.runQuery("COMMIT");
    }
    catch (err){
      //roll back the delete if error occured
      await this.runQuery("ROLLBACK");
      console.error("Error deleting Calendar:", err);
    }

  }

  //Deletes an event from a calendar - Complete
  async deleteEvent(EventID: number): Promise<void> {
    const sqlDeleteEventAdded = "DELETE FROM EventAdd WHERE EventID = ?";
    const sqlDeleteECore = "DELETE FROM EventCore WHERE Eid = ?";
    const sqlDeleteEType = "DELETE FROM EventType WHERE EventID = ?";
    const sqlDeleteETime = "DELETE FROM EventTime WHERE EventID = ?";

    //wrap all sql commands in a "Packet" so that in the instance of a server crash,
    //it can rollback to the previous stable state
    await this.runQuery("BEGIN TRANSACTION");

    try{
      //Delete the EventTime from EventType table
      await this.runQuery(sqlDeleteEType, [EventID]);
      console.log(`Type mapping ${EventID} Deleted from Type.`);

      //Delete the Event from EventCore table
      await this.runQuery(sqlDeleteECore, [EventID]);
      console.log(`Event ${EventID} Deleted from EventCore.`);

      //Delete all mappings of this Event to Calendar from EventAdd table
      await this.runQuery(sqlDeleteEventAdded, [EventID]);
      console.log(`Event mapping ${EventID} Deleted from EventAdd.`);

      //Delete from EventTime table
      await this.runQuery(sqlDeleteETime, [EventID]);
      console.log(`Event mapping ${EventID} Deleted from EventTime.`);

      //end the transaction
      await this.runQuery("COMMIT");
    }
    catch (err){
      //roll back the delete if error occured
      await this.runQuery("ROLLBACK");
      console.error("Error deleting Event:", err);
    }
  }

  //Finds all Calendar IDs from a group - complete
  async findCidsFromGCal(Gid: number): Promise<number[]> {
    const sqlFindCIDs = `SELECT CalendarID FROM GCal WHERE GroupID = ?`;
    const rows: number[] = await new Promise((resolve, reject) => {
      this.db.all(sqlFindCIDs, [Gid], (err: Error | null, rows: any[]) => {
        if (err) {
          return reject(err);
        }
        const ids = rows.map(row => row.CalendarID);
        console.log(`Calendar Ids of Group ${ids}`);
        resolve(ids);
      });
    });
    return rows;
  }

  //Finds all Event IDs from a calendar - complete
  async findEidsFromCalendar(calID: number): Promise<number[]> {
    const sqlFindEIDs = `SELECT EventID FROM EventAdd WHERE CalendarID = ?`;
    const ids: number[] = await new Promise((resolve, reject) => {
      this.db.all(sqlFindEIDs, [calID], (err: Error | null, rows: any[]) => {
        if (err) {
          return reject(err);
        }
        const r = rows.map(row => row.EventID);
        console.log(`Event Ids of calendar ${r}`);
        resolve(r);
      });
    });
    return ids;
  }

  //Finds Group ID from a User - complete
  async findGroupFromUser(UID: number): Promise<number | null> {
    const sqlFindGIDs = `SELECT GroupID FROM Included WHERE UserID = ?`;
    const row: any = await new Promise((resolve, reject) => {
      this.db.get(sqlFindGIDs, [UID], (err: Error | null, row: any) => {
        if (err) return reject(err);
        resolve(row);
      });
    });
    if (!row) {
      console.log(`No group found for user ${UID}`);
      return null;
    }

    return row.GroupID;
  }
}

// This is way better than instantiating the db class in every endpoint
export const db = new DatabaseAggregateFunctions('calendar');